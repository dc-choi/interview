# OOP

## 개요
절차지향은 명령어와 함수 중심으로 문제를 바라보지만, 객체지향은 데이터와 행위를 묶은 객체들의 협력으로 프로그램을 구성한다.

객체는 상태(데이터)와 행동(함수)을 함께 가지며 메시지를 주고받아 일을 수행한다.

대규모 시스템에서 변경에 유연하고 유지보수가 쉬워지는 장점이 있다.

## 역할과 구현
역할(인터페이스)과 구현(클래스)을 분리하면 구조가 단순해지고 변경이 쉬워진다.

- 클라이언트는 역할만 알면 된다.
- 구현 내부가 바뀌어도 클라이언트에 영향이 없다.
- 구현 객체를 교체해도 시스템이 흔들리지 않는다.

## 객체지향 특징
### 추상화
공통 속성과 기능을 뽑아 핵심만 표현한다.

### 캡슐화
외부에 필요한 정보만 노출하고 내부 상태를 보호한다. 접근 제어자는 public/protected/private로 구분한다.

### 상속
기존 클래스를 재사용해 확장하고 코드 중복을 줄인다.

### 다형성
상위 타입 참조로 하위 구현을 다룰 수 있어 교체와 확장이 가능해진다.

```Java
class Car {
    String type;
}

class SuperCar extends Car {
}

Car car = new Car();
Car supercar = new SuperCar();
```

다운캐스팅은 타입 안정성을 보장할 수 있을 때만 사용한다.

```Java
Car car = new Car();
SuperCar supercar = (SuperCar) car;
```

## 오버라이딩 / 오버로딩
오버라이딩은 상위 클래스의 메서드를 같은 시그니처로 재정의하는 것이다.

오버로딩은 이름은 같고 매개변수 목록이 다른 메서드를 정의하는 것이다.

## 객체지향 설계 시 주의
1. 객체 설계는 역할부터 정의하고 구현을 나중에 붙인다.
2. 객체는 항상 협력 관계를 가진다. 단독 객체만으로 동작하지 않는다.

## SOLID 원칙
### SRP
클래스는 하나의 책임만 가져야 한다. 변경에 대한 영향 범위를 최소화한다.

### OCP
확장에는 열려 있고 변경에는 닫혀 있어야 한다. 다형성과 조합을 활용한다.

### LSP
하위 타입은 상위 타입을 대체할 수 있어야 한다. 계약을 위반하면 안 된다.

### ISP
범용 인터페이스 하나보다 클라이언트 맞춤 인터페이스를 여러 개로 나누는 것이 좋다.

### DIP
구체 클래스가 아니라 추상(인터페이스)에 의존하도록 설계한다.

## 정리
객체지향의 핵심은 다형성이다. 하지만 다형성만으로 OCP/DIP를 보장하기 어렵다.

DI 컨테이너나 조립/설정자를 통해 역할과 구현을 분리하면 변경에 강한 구조를 만들 수 있다.

추상화는 비용이 있으므로 변화 가능성이 높은 지점에만 적용한다.
