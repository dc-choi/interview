# Index

데이터베이스의 테이블의 동작 속도를 높여주는 자료구조이다.

책의 찾아보기와 같으며 Key-Value 형식으로 이루어져 있다. SortedList로 구현되어있기 떄문에 인덱스를 생성할 때마다 내부적으로 정렬되어 저장된다.

결론적으로 인덱스란 CUD 성능을 희생하고 Read에 대한 성능을 높이는 기능이다.

## 순차 I/O VS 랜덤 I/O
```
1. 순차IO: 물리적으로 인접한 페이를 차례대로 읽는 순차 접근 방식, 원하는 데이터를 찾기 위해서 풀 스캔 방식을 사용해야 하며 풀 테이블 스캔에 사용
2. 랜덤IO: 물리적으로 떨어진 페이지들에 임의로 접근하는 임의 접근 방식이며 인덱스 레인지 스캔에 사용됨
```

## Primary Key VS Secondary Key
- PK는 우리가 흔히 알고 있는 식별자를 의미한다. 테이블에서 PK를 생성하면 Index에 PK에 관한 인덱스가 생긴 것을 볼 수 있다. 즉 PK는 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미한다. PK를 제외한 나머지 인덱스들을 SK라고 한다.

## Unique VS Non-Unique
- 데이터의 중복 허용 여부로 구분하면 유니크 인덱스와 유니크 하지 않은 인덱스로 나눌 수 있다. 인덱스가 유니크한지 아닌지는 DBMS의 쿼리를 실행해야 하는 옵티마이저한테 중요하다 값이 유니크하면 유니크 인덱스에 대해 동등 조건으로 검색한다는 것을 옵티마이저에게 알려줄 수 있다.

## B-Tree
```
1. 데이터 접근 퍼포먼스가 데이터 증가량에 따라서 결코 선형적으로 증가하지 않는다.
2. 컬럼의 값을 변경하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘
3. Root, Branch, Leaf Node로 구성
4. 각 노드는 페이지를 의미하고 InnoDB에서 페이지란 디스크에 데이터를 저장하는 기본단위다.
5. 블록이라고 불리기도 하고 디스크의 모든 읽기 및 쓰기 작업의 최소 단위가 된다.
6. 인덱스도 페이지 단위로 관리되며 모든 페이지의 크기는 16KB로 고정되어 있다.
7. 루트와 브런치 노드는 인덱스 레코드와 자식 노드 주소를 가지고 있으며 리프 노드는 인덱스 레코드와 레코드 주소를 가지고 있다. 인덱스 레코드는 해당 인덱스에 대한 레코드 값을 의미한다.
8. 리프 노드의 레코드 주소는 실제 테이블에 저장되어 있는 레코드를 가리키게 된다.
```

## Mysql에서 레드 블랙 트리말고 B-Tree를 사용하는 이유
- 레드 블랙 트리 자체는 효율적이지만 대용량 데이터의 경우 트리의 높이를 제어할 수 없다.
- 트리의 높이가 높다면 그만큼 데이터를 조회하는데 시간이 많이 소모된다는 것이다.
- B-Tree는 루트 -> 브런치 -> 리프 -> 데이터 조회 방식으로 조회되기 떄문에 IO를 효과적으로 하기 위해 B-Tree를 선택하였다.

## 인덱스 레인지 스캔
```
1. 인덱스 풀 스캔보다 빠르며, 검색해야할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
2. 리프 노드에서 시작할 지점을 찾으면 그 다음부터는 리프 노드의 레코드만 순서대로 읽으면 된다. 리프 노드의 끝까지 읽으면 리프 노드간의 링크를 통해 다음 리프 노드를 찾아서 스캔한다.
3. 최종적으로 스캔 종료 지점을 찾으면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 종료한다.
4. 인덱스를 통해 읽어야 할 데이터가 전체의 20 ~ 25%를 넘으면 인덱스를 사용하지 않고 테이블 스캔 방식이 더 효율적인 처리 방식이 된다.
5. 인덱스를 읽을 때 랜덤 IO를 통해 가져오게 되는데 이는 하나의 행에 대해 일일히 시스템 콜을 하게되어 효율이 떨어진다고 함.
6. 인덱스 레인지 스캔은 Mysql에서 실행 계획을 볼 때 range로 나온다.
보통 const, ref, range 접근 방법을 구분해서 얘기하는 경우는 거의 없고 이 세가지를 통틀어서 인덱스 레인지 스캔 또는 레인지 스캔이라고 말하는 경우가 많다.
7. 주로 <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산을 이용해 인덱스를 검색할 때 사용됨
```

## 인덱스 풀 스캔
```
1. 인덱스의 처음부터 끝까지 스캔하는 방식을 말한다.
2. 리프 노드의 시작 혹은 끝으로 이동하여 리프 노드를 연결하는 LinkedList를 따라서 처음부터 끝까지 탐색하는 방식이다.
3. 인덱스의 크기는 테이블의 크기보다 훨씬 작기 때문에 테이블 풀 스캔보다 빠른 방식이다.
```

## 클러스터링 인덱스
```
1. PK 값이 비슷한 레코드까리 묶어서 저장하는 것
2. PK에 대해서만 적용되는 내용이며 Mysql에서 PK를 생성하는 경우 자동으로 인덱스가 생성되는데 해당 인덱스를 클러스터링 인덱스라고 한다.
3. 테이블당 하나만 생성이 가능하다. 따라서 PK에 의해 레코드의 저장 윛치가 결정되며 PK가 변경되면 저장 위치도 변경된다.
4. InnoDB는 항상 클러스터링 인덱스로 저장된다. 즉 테이블의 레코드가 PK값으로 정렬되어 저장된다는 의미이다.
5. 공간 지역성이 좋아서 PK 기반으로 범위 검색이 빠르다.
6. PK의 변경이 느리다. PK가 자주 변경되는 값으로 설정된 경우 DB 성능 이슈가 발생할 수 있다.
매번 변경될 때마다 저장 위치가 조정되면서 성능 이슈가 발생한다.
그래서 자주 변경되는 값은 유니크키로 잡고 PK를 AUTO_INCREMENT를 사용한 인조키를 사용하게 된다.
```

## 논 클러스터링 인덱스
```
1. 클러스터링 인덱스에 비해서 검색 속도는 느린 반면에 CUD 속도는 빠르다.
2. 리프 노드 자체가 데이터가 아니고, 데이터가 위치하는 주소를 가지고 있는 형태이다.
3. 사용자가 등록하는 인덱스들이 논 클러스터링 인덱스에 속한다.
4. 클러스터 인덱스는 페이지를 알기 때문에 해당 페이지를 바로 펴는 것이고,
논 클러스터 인덱스는 책 뒤의 찾아보기에서 원하는 내용과 페이지를 찾고 이동하는 것
테이블 풀 스캔은 책을 처음부터 한장한장 넘기면서 원하는 내용을 찾는 것 이라고 생각하면 된다.
```
