## Controller
수신 요청을 처리하고 클라이언트에 응답을 다시 보내는 일을 담당.

Controller의 목적은 애플리케이션에 대한 특정 요청을 처리하는 것.

라우팅 메커니즘에 따라 각 요청을 처리할 Controller가 결정됨.

Controller에는 여러 개의 경로가 있는 경우가 많으며 각 경로마다 다른 작업을 수행.

### 라우팅
라우팅이 성공하면 200 상태 코드를 반환하며, 이 경우 문자열입니다.

왜 이런 일이 발생할까요?

이를 설명하기 위해 먼저 Nest가 응답을 조작하는 데 두 가지 옵션을 사용한다는 개념을 소개할 필요가 있습니다.

1. 표준
    ```
   표준을 사용하면 요청 핸들러가 JavaScript 객체나 배열을 반환하면 자동으로 JSON으로 직렬화됩니다.
   
   그러나 JavaScript 기본 유형(예: 문자열, 숫자, 부울)을 반환하는 경우 Nest는 직렬화를 시도하지 않고 값만 전송합니다.
   
   따라서 응답 처리가 간단해집니다. 값만 반환하면 나머지는 Nest가 처리합니다.
   
   또한 응답의 상태 코드는 201을 사용하는 POST 요청을 제외하고는 기본적으로 항상 200입니다.
   
   핸들러 수준에서 @HttpCode(...) 데코레이터를 추가하여 이 동작을 쉽게 변경할 수 있습니다.
    ```

2. 사용자 정의
    ```
   라이브러리별(예: Express) 응답 객체를 사용할 수 있으며, 메서드 핸들러 시그니처에 @Res() 데코레이터를 사용하여 삽입할 수 있습니다.
   
   이 접근 방식을 사용하면 해당 객체에 의해 노출된 기본 응답 처리 메서드를 사용할 수 있습니다.
   
   예를 들어 Express에서는 response.status(200).send()와 같은 코드를 사용하여 응답을 구성할 수 있습니다.
   
   Nest는 핸들러가 @Res() 또는 @Next()를 사용하는 경우를 감지하여 라이브러리별 옵션을 선택했음을 나타냅니다.
   
   두 가지 접근 방식을 동시에 사용하면 이 단일 경로에 대해 표준 접근 방식이 자동으로 비활성화되고 더 이상 예상대로 작동하지 않습니다.
   
   두 접근 방식을 동시에 사용하려면 @Res({ passthrough: true }) 데코레이터에서 passthrough 옵션을 true로 설정해야 합니다.
    ```

### 요청 객체
핸들러는 종종 클라이언트의 요청 세부 정보에 액세스해야 합니다.

Nest는 기본 플랫폼(기본적으로 Express)에서 요청 객체에 대한 액세스를 제공합니다.

핸들러의 서명에 @Req() 데코레이터를 사용하여 요청 객체를 삽입하도록 Nest에 지시하여 요청 객체에 액세스할 수 있습니다.

요청 매개변수 예제에서와 같이 익스프레스 타이핑을 활용하려면 @types/express 패키지를 설치해야 합니다.

요청 객체는 HTTP 요청을 나타내며 쿼리 문자열, 매개변수, HTTP 헤더 및 본문에 대한 속성을 포함합니다.

대부분의 경우 이러한 속성에 수동으로 액세스할 필요가 없습니다.

대신 바로 사용할 수 있는 @Body() 또는 @Query()와 같은 전용 데코레이터를 사용할 수 있습니다.

아래는 제공되는 데코레이터와 해당 데코레이터가 나타내는 플랫폼별 객체 목록입니다.

| 데코레이터                   | 설명          | 플랫폼 객체                          |
|-------------------------|-------------|---------------------------------|
| @Request(), @Req()      | 요청 객체       | req                             |
| @Response(), @Res()     | 응답 객체       | res                             |
| @Next()                 | 다음 미들웨어     | next                            |
| @Session()              | 세션 객체       | req.session                     |
| @Param(key?: string)    | 경로 매개변수     | req.params / req.params[key]    |
| @Query(key?: string)    | 쿼리 문자열      | req.query / req.query[key]      |
| @Body(key?: string)     | 요청 본문       | req.body / req.body[key]        |
| @Headers(name?: string) | HTTP 헤더     | req.headers / req.headers[name] |
| @Ip()                   | 클라이언트 IP 주소 | req.ip                          |
| @HostParam()            | 호스트 매개변수    | req.params                      |

기본 HTTP 플랫폼에서의 타이핑과의 호환성을 위해 Nest는 @Res() 및 @Response() 데코레이터를 제공합니다. 

Res()는 @Response()의 별칭일 뿐입니다. 둘 다 기본 네이티브 플랫폼 응답 객체 인터페이스를 직접 노출합니다.

이를 사용할 때는 기본 라이브러리의 타이핑도 가져와야 최대한 활용할 수 있습니다.

메서드 핸들러에 @Res() 또는 @Response()를 삽입하면 해당 핸들러에 대해 Nest를 라이브러리 전용 모드로 전환하고 응답을 관리할 책임이 있다는 점에 유의하세요.

이 경우 응답 객체(예: res.json(...) 또는 res.send(...))를 호출하여 일종의 응답을 발행해야 하며, 그렇지 않으면 HTTP 서버가 중단됩니다.

### 리소스
Nest는 모든 표준 HTTP 메서드에 대한 데코레이터를 제공합니다: Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head(). 또한 @All()은 이 모든 메서드를 처리하는 엔드포인트를 정의합니다.

### 상태 코드
앞서 언급했듯이 응답의 기본 상태 코드는 기본값이 201인 POST 요청을 제외하고 항상 200입니다.

핸들러 수준에서 @HttpCode(...) 데코레이터를 사용하여 이 동작을 쉽게 변경할 수 있습니다.

nestjs/common 패키지에서 HttpCode를 가져옵니다.

상태 코드는 정적이지 않고 다양한 요인에 따라 달라지는 경우가 많습니다.

이 경우 라이브러리별 응답(@Res()를 사용하여 삽입) 객체를 사용하거나 오류가 발생하면 예외를 던질 수 있습니다.

### 응답 헤더
사용자 지정 응답 헤더를 지정하려면 @Header() 데코레이터 또는 라이브러리별 응답 객체를 사용하거나 res.header()를 직접 호출하면 됩니다.

nestjs/common 패키지에서 Header를 가져옵니다.

### 리다이렉션
응답을 특정 URL로 리디렉션하려면 @Redirect() 데코레이터 또는 라이브러리별 응답 객체를 사용하거나 res.redirect()를 직접 호출하면 됩니다.

리디렉션()은 두 개의 인자, url과 statusCode를 받으며 둘 다 선택 사항입니다.

statusCode의 기본값은 생략 시 302(Found)입니다.

때로는 HTTP 상태 코드나 리디렉션 URL을 동적으로 확인하고 싶을 수 있습니다.

이를 위해서는 @nestjs/common의 HttpRedirectResponse 인터페이스를 따르는 객체를 반환하면 됩니다.

반환된 값은 @Redirect() 데코레이터에 전달된 모든 인수를 재정의합니다.

### 경로 매개변수
정적 경로를 사용하는 경로는 요청의 일부로 동적 데이터를 받아들여야 하는 경우 작동하지 않습니다.

매개변수가 있는 경로를 정의하려면 경로 경로에 경로 매개변수 토큰을 추가하여 URL에서 동적 값을 캡처할 수 있습니다.

그런 다음 메서드 서명에 추가해야 하는 @Param() 데코레이터를 사용하여 이러한 경로 매개변수에 액세스할 수 있습니다.

매개변수가 있는 경로는 정적 경로 뒤에 선언해야 합니다.

이렇게 하면 매개변수화된 경로가 정적 경로로 향하는 트래픽을 가로채는 것을 방지할 수 있습니다.

Param() 데코레이터는 메소드 매개변수를 장식하는 데 사용되며, 경로 매개변수를 메소드 내에서 장식된 메소드 매개변수의 속성으로 액세스할 수 있도록 합니다.

또는 특정 매개변수 토큰을 데코레이터에 전달하고 메서드 본문 내에서 이름으로 경로 매개변수를 직접 참조할 수 있습니다.

nestjs/common 패키지에서 Param을 가져옵니다.

### 서브 도메인 라우팅
Controller 데코레이터는 호스트 옵션을 사용하여 들어오는 요청의 HTTP 호스트가 특정 값과 일치하도록 요구할 수 있습니다.

Fastify는 중첩 라우터를 지원하지 않으므로 하위 도메인 라우팅을 사용하는 경우 기본 Express 어댑터를 대신 사용하는 것이 좋습니다.

경로 경로와 마찬가지로 호스트 옵션은 토큰을 사용하여 호스트 이름에서 해당 위치의 동적 값을 캡처할 수 있습니다.

이러한 방식으로 선언된 호스트 매개변수는 메서드 시그니처에 추가해야 하는 @HostParam() 데코레이터를 사용하여 액세스할 수 있습니다.

### 상태 공유
다른 프로그래밍 언어를 사용하는 개발자에게는 Nest에서 거의 모든 것이 수신 요청에 걸쳐 공유된다는 사실이 놀랍게 느껴질 수 있습니다.

여기에는 데이터베이스 연결 풀, 전역 상태를 가진 싱글톤 서비스 등과 같은 리소스가 포함됩니다.

Node.js는 각 요청이 별도의 스레드에서 처리되는 request/response Multi-Threaded Stateless Model을 사용하지 않는다는 점을 이해하는 것이 중요합니다.

따라서 Nest에서 싱글톤 인스턴스를 사용하는 것은 애플리케이션에 완전히 안전합니다.

하지만 Controller에 요청 기반 수명을 설정해야 하는 특정 사례가 있을 수 있습니다.

예를 들어 GraphQL 애플리케이션의 요청별 캐싱, 요청 추적 또는 멀티테넌시 구현 등이 있습니다.

[Injection Scope](../fundamentals/Injection-Scopes.md)에 대한 내용은 링크에서 자세히 알아볼 수 있습니다.

### 비동기
우리는 특히 비동기 데이터 처리를 좋아합니다.

이것이 바로 Nest가 비동기 함수를 완벽하게 지원하는 이유입니다.

모든 비동기 함수는 반드시 Promise를 반환해야 하며, 이를 통해 Nest가 자동으로 확인할 수 있는 지연된 값을 반환할 수 있습니다.

그러나 Nest는 경로 핸들러가 RxJS observable streams 도 반환할 수 있도록 허용함으로써 한 단계 더 나아갑니다.

Nest는 내부적으로 구독을 처리하고 스트림이 완료되면 최종 방출된 값을 확인합니다.

두 가지 접근 방식 모두 유효하며 필요에 가장 적합한 방식을 선택할 수 있습니다.

### 요청 본문
계속 진행하기 전에 DTO를 정의해야 합니다.

DTO는 네트워크를 통해 데이터를 전송하는 방법을 지정하는 객체입니다.

인터페이스 또는 클래스를 사용하여 DTO 스키마를 정의할 수 있습니다.

그러나 공식문서 상에서는 클래스를 추천합니다.

왜 그럴까요? 클래스는 자바스크립트 ES6 표준의 일부이므로 컴파일된 자바스크립트에서 실제 엔티티로 그대로 유지됩니다.

반면에 인터페이스는 트랜스파일링 중에 제거되므로 Nest는 런타임에 이를 참조할 수 없습니다.

Pipes 와 같은 기능은 런타임에 변수의 메타타입에 액세스할 수 있어야 하는데, 이는 클래스를 통해서만 가능하기 때문에 이 점이 중요합니다.

ValidationPipe 는 메서드 핸들러가 수신해서는 안 되는 프로퍼티를 필터링할 수 있습니다.

이 경우 허용 가능한 속성을 화이트리스트에 추가할 수 있으며, 화이트리스트에 포함되지 않은 속성은 객체에서 자동으로 제거됩니다.

[여기](../fundamentals/Validation)에서 자세히 알아보세요.

### 쿼리 문자열
라우트에서 쿼리 매개변수를 처리할 때 @Query() 데코레이터를 사용하여 수신 요청에서 해당 매개변수를 추출할 수 있습니다.

`qs`는 중첩과 배열을 지원하는 쿼리 문자열 구문 분석기입니다. `npm install qs`를 사용하여 설치할 수 있습니다.
