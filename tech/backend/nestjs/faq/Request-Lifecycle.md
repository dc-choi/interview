## Request-Lifecycle
NestJS의 요청 라이프사이클은 다음과 같다.

### 1. Middleware
- Express 미들웨어와 유사
- 전역 => 모듈 => 라우터 순으로 작동
- 요청과 응답 객체에 직접 접근 가능
- next() 함수를 통한 제어 흐름 관리
- 활용 사례: 로깅 && 요청 파싱, CORS 설정, 요청 본문 파싱, 인증 토큰 검증

### 2. Guards
- 인증과 권한 검사를 수행합니다.
- 글로벌 => 컨트롤러 => 라우팅 메서드 순으로 작동
- 의존성 주입 가능
- 활용 사례: 인증/인가 처리, 역할 기반 접근 제어, API 키 검증

### 3. Interceptors
- 메소드 실행 전에 추가 로직을 실행할 수 있습니다.
- 글로벌 => 컨트롤러 => 라우팅 메서드 순으로 작동
- 요청과 응답을 모두 처리 가능
- RxJS 연산자를 사용한 스트림 조작
- 응답을 변환할 수 있습니다.
- 활용 사례: 응답 형식 표준화, 캐싱, 응답 시간 측정, 에러 핸들링

### 4. Pipes
- 데이터 변환 및 유효성 검사를 수행합니다.
- 글로벌 => 컨트롤러 => 라우팅 메서드 => 파라미터 순으로 작동
- 활용 사례: DTO 유효성 검사, 타입 변환, 기본값 설정, 커스텀 데이터 변환

### 5. Controllers
- 실제 요청을 처리하는 부분입니다.
- 라우팅 로직 처리
- 요청과 응답의 인터페이스 정의
- 데코레이터를 통한 메타데이터 정의
- 활용 사례: API 엔드포인트 정의, 요청 파라미터 처리, 응답 데이터 구조화, 비즈니스 로직 위임

### 6. Services
- 비즈니스 로직을 처리하는 부분입니다.
- 활용 사례: 비즈니스 로직 수행, 데이터베이스 접근, 외부 API 호출, 파일 시스템 접근

### 7. Interceptors

### 8. Exception Filters
- 과정 중 발생한 예외를 처리합니다.
- 예외 처리의 중앙화
- HttpException을 처리
- 커스텀 예외 응답 포맷 정의
- 활용 사례: 에러 로깅, 사용자 정의 에러 응답, 글로벌 에러 처리, 특정 예외에 대한 커스텀 처리
