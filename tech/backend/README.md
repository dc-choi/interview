### VO
value object의 약어이다. 불변의 특징을 가지고 있고 모든 속성이 같은 값을 가져야 동일한 객체로 판단한다.

### DTO
데이터 전송 객체는 요청과 응답을 처리하기 위한 객체라고 생각하면 된다.

일반적으로 Request와 Response로 구분지어서 사용한다. REST API를 설계하는 경우 API 응답으로 엔티티를 쓰게되면, 엔티티에 속성이 추가되거나 삭제될 때마다 API 명세가 바뀌게 된다. 이 경우 API 명세가 테이블에 의존하는 현상이 발생하므로 DTO에게 의존하도록 하는 것이다.

### IOC(Inversion of Control)
제어의 역전이라는 뜻으로 개발자가 직접 객체를 관리하지 않고 스프링 컨테이너에서 직접 객체를 생성하여 해당 객체에 주입하는 객체 생명 관리, 흐름제어를 담당하는 프로그래밍 모델이다.

스프링에서 IOC를 선택한 이유는 객체마다 올바른 캡슐화를 통해 높은 응집도와 낮은 결합도를 이루어나가는 것이 핵심이며 변경에 유연한 코드 구조를 가져가기 위해서이다. 결론적으로 개발자가 비즈니스로직에만 관심을 가지도록 객체의 관리를 위힘하는 것.

### DI(Dependency Injection)
스프링에서 IOC 프로그래밍 모델을 구현하는 구체적인 방법이다. 클래스타입을 고정시키지 않고 인터페이스 타입의 파라미터를 통해 다이나믹하게 구현 클래스를 결정해서 제공받을 수 있다.

### AOP(Aspect Oriented Programming)
관점 지향 프로그래밍으로 공통 관심사를 모듈화하여 핵심 비즈니스 로직과 분리하는 프로그래밍 패러다임이다.

AOP를 사용하면 비즈니스 로직과 공통 관심사를 분리할 수 있다. 즉, 비즈니스 로직에 영향을 주지 않고도 공통 관심사를 변경할 수 있다.

### ORM
ORM을 사용하게 될 경우 객체와 관계형 DB를 매핑한다. 즉 객체가 DB 테이블이 되도록 만들어주는 것이다.

ORM을 사용하면 SQL을 작성하지 않아도 직관적인 메서드로 관리할 수 있다. 이는 개발자에게 생산성을 보장한다.

Node.js에서 ORM은 크게 3가지로 나뉜다. Sequelize, TypeORM, Prisma가 있다.

1. 특징
- 객체 중심 개발 가능
  ```
  1. SQL 중심 개발이 이루어진다면, CRUD 작업이 반복해서 이루어져야한다.
  2. 하나의 테이블을 생성해야 할 때 이에 해당하는 CRUD를 전부 만들어야 한다.
  이는 추후에 컬럼이 생성되면 관련 SQL을 모두 수정해야 하는 번거로움이 있다.
  또한 개발 과정에서 실수할 가능성도 높아진다.
  ```
- 생산성 증가
  ```
  1. SQL 쿼리를 직접 생성하지 않고 만들어진 객체에 메서드를 활동해 DB를 다루기 때문에 개발자에게 매우 편리성을 제공한다.
  ```
- 단, 복잡한 쿼리는 SQL이나 쿼리빌더로 짜는게 더 유리함.

### Entity
ORM에서 사용되는 개념이다. 실제 테이블과 정확하게 매칭되는 프로퍼티들을 가지도록 디자인된 클래스다.

비즈니스 로직을 엔티티로 모음으로써 응집도가 높아지게 된다.

### N+1 문제
한번의 쿼리로 N건의 데이터를 가져온 후 원하는 데이터를 얻기 위해서 N건의 데이터 수 만큼 2차 쿼리를 날리는 것으로 ORM의 성능 저하를 일으키는 대표적인 이슈이다.

먼저 ORM의 Lazy Loading과 Eager Loading에 대해서 설명을 필요함.

1. Lazy Loading
- 현재 접근하는 메인 모델과 관련이 있는 모델의 데이터를 조회할 때, 메인 모델에 먼저 접근하고 관련 모델은 필요할 때 접근한다.
2. Eager Loading
- 메인 모델에 접근할 때 관련 테이블을 조인해서 한번에 데이터를 조회한다.

해결 방법은 다음과 같음.
1. Eager Loading을 사용한다.
2. Raw Query를 사용한다.